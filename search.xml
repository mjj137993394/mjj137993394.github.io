<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mac OSX上搭建Apache，PHP，MySQL，phpMyAdmin开发环境]]></title>
      <url>%2F2017%2F03%2F07%2FMac_PHP_Apache_Mysql%2F</url>
      <content type="text"><![CDATA[用惯了Windows上的集成环境，换了Mac还真不习惯，不过Mac确实舒服，基于毕业设计要求得捣腾一个PHP开发环境。但自己亲自配一下环境还是有所收获的。众所周知OSX上自带了apache和PHP，所以这两个搞起来还比较顺利。本文详细记录配置过程。 apache的配置apache已经自带了，只需如下三个命令就可以了。开启apache服务 sudo apachectl start停止apache服务 sudo apachectl stop重启服务 sudo apachectl restart查看版本 httpd -v 手动打开apache服务后，在浏览器输入localhost，将看到如下： 程序的根目录在/Library/WebServer/Documents/ 下，这个It works 就是里面的info.php打印出来的。下面介绍如何将apache的这个默认目录更改到用户目录下。1.在自己的用户目录下新建一个Sites文件夹，我的用户目录为junjiemao 2.进到cd /etc/apache2/users/目录下，sudo vim junjiemao.conf，内容为： 12345&lt;Directory &quot;/Users/yanzi/Sites/&quot;&gt;AllowOverride AllOptions Indexes MultiViews FollowSymLinksRequire all granted&lt;/Directory&gt; 上面第一行里的yanzi就是用户目录。然后将该文件权限改为644：1sudo chmod 644 junjiemao.conf 3.进到/etc/apache2/目录，sudo vim httpd.conf 将下面三句话的注释去掉：LoadModule authz_core_module libexec/apache2/mod_authz_core.soLoadModule authz_host_module libexec/apache2/mod_authz_host.soLoadModule userdir_module libexec/apache2/mod_userdir.so前两句应该已经不带注释了，把第三句注释放开。然后找到Include /private/etc/apache2/extra/httpd-userdir.conf 注释放开。PS：在vim下只要切换到命令模式，然后输入/”words you need find”就能快速找到需要查找的词。4.进到/etc/apache2/extra/目录，sudo vim httpd-userdir.conf将Include /private/etc/apache2/users/*.conf 这句话放开注释。 然后终端输入：sudo apachectl restart 重启apache，浏览器输入： loacal/~junjiemao/ 就能看到效果了。（junjiemao是我的用户目录的名字,后面不用再加/Sites）经过以上步骤apache就搞好了。 PHP配置PHP的配置非常简单，就一个事，进到/etc/apache2/目录，编辑httpd.conf，找到LoadModule php5_module libexec/apache2/libphp5.so将其放开注释就行了。 然后sudo apachectl restart 重启，在用户目录的Sites文件夹下，新建一个index.php,里面echo phpinfo() ，就可以看到效果了： 安装MySQL5.7.2171.官网下载dmg版本文件，按步骤安装，安装完毕后，在设置—MySQL手动开启MySQL服务。2.默认状态下，我们用mysql的命令每次都要输入全路径，如sudo /usr/local/mysql/support-files/mysql.server start 开启mysql服务，/usr/local/mysql/bin/mysql -v查看mysql版本，得先把bin目录配到环境变量里。切换到用户根目录 ，vim .bash_profile,输入：export PATH=”/usr/local/mysql/bin:$PATH”保存后，source .bash_profile使环境变量生效。接着就可以直接在终端里输入mysql命令了。最后，通过mysqladmin -u root password ‘yourpasswordhere’ 给mysql的root用户设置密码。单引号里的内容就是要设的密码。 phpMyAdmin的安装从http://www.phpmyadmin.net/home_page/downloads.php 下载，我下的是phpMyAdmin-4.4.2-all-languages.zip这个版本，将其解压。然后最外层文件夹名字修改为phpmyadmin，进到~/Sites/phpmyadmin这个目录，新建文件夹：mkdir config 修改读写权限：chmod o+w config然后浏览器输入：http://localhost/~junjiemao/phpmyadmin/setup/ (注意 中间的junjiemao换成自己的用户名称) 配置文件记得保存到phpmyadmin文件目录下才能生效，MySQL密码记得修改。发生（#2002 - No such file or directory &mdash; 服务器没有响应（或本地服务器的套接字没有正确设置）。）错误解决办法： 输入http://localhost/~junjiemao/phpmyadmin/ 就可以看到登陆phpmyadmin的界面了。 如此，phpMyAdmin搞定。 OK，PHP在MAC上的搭建到此结束。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端常用学习网站]]></title>
      <url>%2F2017%2F02%2F28%2Fstudy_web%2F</url>
      <content type="text"><![CDATA[前端常用学习网站 @(welcome)[前端菜鸟|掘金中] 技术网站 博客园 前端观察 前端网 推酷 大前端 web前端开发 web骇客 掘金 百度FEX 淘宝前端团队 segmentfault 优设 阮一峰javascript教程 漠然GitHub 芝哥GitHub 程序员宝典 资源整合 前端资源汇集 前端总结 前端知识大全 移动端WEB资源整合 全栈修炼 阮一峰全栈修炼营 一个全栈增长工程师的练手项目集 百度前端技术学院开发任务 FreeCodeCamp中文网 各种Book 宁皓网 Web开发实战 Javascript半知半解 前端工具 免费CDN BootCDN weinre远程调试工具 JSLint 图标库 flex布局 WeUI-微信官方网页开发样式库 Babel-支持ES6 翻墙工具 取色卡 网站安全色 MDN-分享知识 JSDoc-生成js文档 jekyll-在git上制作个人博客 思维导图 站酷 Bootstrap在线制作 Bootstrap本地编辑器Jetstrap 远程工作teamviewer下载 开发APP的设计利器SKETCH 云IDE–CODEPEN HipChat git css动画cubic-bezier工具 JS库 jQuery中文文档 requireJS中文 backboneJS angularJS教程 underscoreJS juicer-DOM拼接 sweetAlert-弹出框 ES6入门 TypeScript-基于ES6 handlebars-DOM拼接 移动端开发框架 artTemplate-DOM拼接 ReactJS ECharts1.0-网页图表 ECharts2.0-网页图表 CoffeeScript-简化编写JS D3js-扁平化图表 BUTTONS-详尽的按钮样式 Lodash-超越undersore的js库 video.js Loading动画 G2-图表插件 网页幻灯片impressJS 数据操作lodashJS VueJS中文 Vue-router中文 Vue-组件1 Vue-组件2 移动端上下划动onepage-scroll.js 数字滚动动画CountUp.js A-Frame框架–实现VR效果 TypeScript版本大全 Three.js官 WebGl中文网 jQuery插件及特效 jQuery-瀑布流布局异步图片加载 后台管理模板WrapBootstrap jQuery WeUI jQuery3d幻灯片翻页效果 jQuery-unslider图片轮播 插件库 各种模态框 跨浏览器复制jQuery.zlip jQurty.fullPage-一页滚动演示 炫酷前端动画 插件库 express vue组件库 vue-drapload上拉加载下拉刷新 jade-js的模板 react-Bootstrap React图表组件库-ReCharts React框架MobX React框架Redux:Flux 的函数式实现 json-server模拟服务器API ESLint–静态代码检查工具 Mocha–目前最常用的测试框架 Nightmare功能测试 H5和CSS3 BootStrap Animate.css HTML5 Boilerplate–快速搭建前端网站 Fla UI-扩充bootstrap的样式组件库 Normalize.css–重置样式 less sass 代码优化 CSS LINK-在线css优化工具 JSHint-js检测工具 快速搭建项目 yeomanl Function Modernizr–实现优雅降级 UIkit 阮一峰全栈搭建 深度好文JavaScript防http劫持与XSSH5兼容解决方案-polyfillHTML5 Cross Browser PolyfillsJavaSript模块规范 AMD规范与CMD规范REST架构风格console的特性完全版超棒的面试题gulp与grunt对比大型JavaScript应用程序架构模式前端模块管理器介绍-阮一峰前端爱玩网仓库REST架构风格深入理解什么是web服务器手写ajax前端调试方式jQuery的deferred前端职业发展之路angularJS之directiveVue-router思维导图我是如何利用一个周末时间成为前端工程师的Echarts在线案例github使用介绍环状进度球webpack搭建vue教程/)git冲突解决angularjs指令的@=&amp;一张图告诉你什么是公钥密钥移动短head标签 前端搭建工具 webpack nodeJS官网 nodeJS中文网 grunt gulp教程 npm Express 廖雪峰官方网站 初级webpack配置 webpack菜鸟配置 .jshintrc常用配置 package.json配置中文文档 .gitignore文件模板-全 bower Gulp自动化工具 前端服务器 apache nginx 关于工具 mac数据迁移-迁移助理 翻墙Shadowsocks HipChat Goole本地翻墙 Goole翻墙网址 hexo搭建博客 hexo主题皮肤yilia IDEA注册码 远程调试工具weinre使用教程 Babel在线编辑 DNSPod腾讯云服务 验证码服务 关于mac Homebrew linux命令-漠然 mac内存清理工具clean my mac 终端配置 oh my zsh vpn连接 上手mac 命令行艺术 程序猿如何优雅的用mac 编辑软件 WebStorm markdown在线编辑器.md 前后端通道 Thymeleaf Spring Cloud微服务解决方案 company SVN [NodeBB论坛管理地址] 公司后台直通车 龙贷社区 微信小程序 微信应用制作 微信小程序开发入门文档 浏览器打开小程序 微信小程序文章集锦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简约至上]]></title>
      <url>%2F2017%2F02%2F23%2Fjyzs%2F</url>
      <content type="text"><![CDATA[简约至上阅读思维导图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何成为一名卓越的前端工程师]]></title>
      <url>%2F2017%2F02%2F23%2FBe_a_goodFE%2F</url>
      <content type="text"><![CDATA[译注：本文翻译自谷歌工程师 Philip Walton 的一篇博客。 最近我收到一封读者来信让我陷入了思考，信是这么写的： Hi Philip，您是否介意我问，您是如何成为一名卓越 (great) 的前端工程师的？对此您有什么建议吗？ 不得不承认，被问这样的问题，我很惊讶，因为我从来不觉得自己是个很卓越的前端工程师。甚至我入行的头几年时并不认为自己可以做好这一行。我只确定自己比自己想象中还才疏学浅，而且大家面试我的时候都不知道从何问起。 话虽这么说，我到现在做得还算不错，而且成为了团队中有价值的一员。但我最终离开 (去寻求新的挑战——即我还不能够胜任的工作) 的时候，我经常会被要求招聘我的继任者。现在回看这些面试，我不禁感叹当我刚开始的时候自己在这方面的知识是多么的匮乏。我现在或许不会按照我自己的模型进行招聘，即便我个人的这种经历也有可能成功。 我在 web 领域工作越长时间，我就越意识到区分人才和顶尖人才的并不是他们的知识——而是他们思考问题的方式。很显然，知识在很多情况下是非常重要而且关键的——但是在一个快速发展的领域，你前进和获取知识的方式 (至少在相当长的一段时间里) 会比你已经掌握的知识显得更加重要。更重要的是：你是如何运用这些知识解决每天的问题的。 这里有许许多多的文章谈论你工作中需要的语言、框架、工具等等。我希望给一些不一样的建议。在这篇文章里，我想谈一谈一个前端工程师的心态，希望可以帮助大家找到通往卓越的道路。 别光解决问题，想想究竟发生了什么很多人埋头写 CSS 和 JavaScript 直到程序工作起来了，然后就去做别的事情了。我通过 code review 发现这种事经常发生。我总会问大家：“为什么你会在这里添加 float: left？”或者“这里的 overflow: hidden 是必要的吗？”，他们往往答道：“我也不知道，可是我一删掉它们，页面就乱套了。” JavaScript 也是一样，我总会在一个条件竞争的地方看到一个 setTimeout，或者有些人无意中阻止了事件传播，却不知道它会影响到页面中其它的事件处理。我发现很多情况下，当你遇到问题的时候，你只是解决当下的问题罢了。但是如果你永远不花时间理解问题的本源，你将一次又一次的面对相同的问题。花一些时间找出为什么，这看上去费时费力，但是我保证它会节省你未来的时间。在完全理解整个系统之后，你就不需要总去猜测和论证了。 学会预见未来的浏览器发展趋势前后端开发的一个主要区别在于后端代码通常都运行在完全由你掌控的环境下。前端相对来说不那么在你的掌控之中。不同用户的平台或设备是前端永恒的话题，你的代码需要优雅掌控这一切。 我记得自己 2011 年之前曾经阅读某主流 JavaScript 框架的时候看到过下面这样的代码 (简化过的)： 12 var isIE6 = !isIE7 &amp;&amp; !isIE8 &amp;&amp; !isIE9; 在这个例子中变量 IE6 为了判断 IE 浏览器版本是否是 6 或更低的版本。那么在 IE10 发布时，我们的程序判断还是会出问题。 我理解在真实世界特性检测并不 100% 工作，而且有的时候你不得不依赖有 bug 的特性或根据浏览器特性检测的错误设计白名单。但你为此做的每一件事都非常关键，因为你预见到了不再有 bug 的未来。对于我们当中的很多人来说，我们今天写的代码都会比我们的工作周期要长。有些我写的代码已经过去 8 年多了还在产品线上运行。这让人很满足又很不安。 阅读规范文档浏览器有 bug 是很难免的事，但是当同一份代码在两个浏览器渲染出来的效果不一样，人们总会不假思索的推测，那个“广受好评”的浏览器是对的，而“不起眼”的浏览器是错的。但事实并不一定如此，当你的假设出现错误时，你选取的变通办法都会在未来遭遇问题。 一个就近的例子是 flex 元素的默认最小尺寸问题。根据规范的描述，flex 元素初始化的 min-width 和 min-height 的值是 auto (而不是 0)，也就是说它们默认应该收缩到自己内容的最小尺寸。但是在过去长达 8 个月的时间里，只有 Firefox 的实现是准确的。 如果你遇到了这个浏览器兼容性的问题并且发现 Chrome、IE、Opera、Safari 的效果相同而 Firefox 和它们不同时，你很可能会认为是 Firefox 搞错了。事实上这种情况我见多了。很多我在自己 Flexbugs 项目上报的问题都是这样的。而且这些解决方案的问题会在两周之后 Chrome 44 修复之后被体现出来。和遵循标准的解决方案相比，这些方案都伤害到了正确的规范行为。当同一份代码在两个或更多浏览器的渲染结果不同时，你应该花些时间确定哪个效果是正确的，并且以此为标准写代码。你的解决方案应该是对未来友好的。额外的，所谓“卓越”的前端工程师是时刻感受变化，在某项技术成为主流之前就去适应它的，甚至在为这样的技术做着贡献。如果你锻炼自己看到规范就能在浏览器支持它之前想象出它如何工作的，那么你将成为谈论并影响其规范开发的那群人。 阅读别人的代码出于乐趣阅读别人的代码可能并不是你每周六晚上会想到的娱乐项目，但是这毫无疑问是你成为优秀工程师的最佳途径。自己独立解决问题绝对是个不错的方式，但是这不应该是你唯一的方式，因为它很快就会让你稳定在某个层次。阅读别人的代码会让你开阔思维，并且阅读和理解别人写的代码也是团队协作或开源贡献必须具备的能力。我着实认为很多公司在招聘新员工的时候犯的最大错误是他们只评估应聘者从轮廓开始写新代码的能力。我几乎没有见过一场面试会要求应聘者阅读现有的代码，找出其中的问题，并修复它们。缺少这样的面试流程真的非常不好，因为你作为工程师的很多时间都花费在了在现有的代码的基础上增加或改变上面，而不是搭建新的东西。 与比你聪明的人一起工作我印象中的很多前端开发者 (相比于全职工作来说) 都是自由职业者，有同类想法的后端开发者并没有那么多。可能是因为很多前端都是自学成才的而后端则多是学校里学出来的。不论是自我学习还是自我工作，我们都面对一个问题：你并没有机会从比你聪明的家伙那里学到什么。没有人帮你 review 代码，也没有人与你碰撞灵感。我强烈建议，最起码在你职业发展的前期，你要在一个团队里工作，尤其是一个普遍比你聪明而且有经验的团队里工作。如果你最终会在你职业发展的某个阶段选择独立工作，一定要让自己投身在开源社区当中。保持对开源项目的活跃贡献，这会给你团队工作相同甚至更多的益处。 “造轮子”造轮子在商业上是非常糟糕的，但是从学习的角度是非常好的。你可能很想把那些库和小工具直接从 npm 里拿下来用，但也可以想象一下你独立建造它们能够学到多少东西。我知道有些人读到这里是特别不赞成的。别误会，我并没有说你不应该使用第三方代码。那些经过充分测试的库具有多年的测试用例积累和已知问题积累，使用它们绝对是非常明智的选择。但在这里我想说的是如何从优秀到卓越。我觉得这个领域很多卓越的人都是我每天在用的非常流行的库的作者或维护者。 你可能不曾打造过自己的 JavaScript 库也拥有一个成功的职业发展，但是你从不把自己手弄脏是几乎不可能淘到金子的。在这一行大家普遍会问的一个问题是：我接下来应该做点什么？如果你没有试着学一个新的工具创建一个新的应用，那不妨试着重新造一个你喜欢的 JavaScript 库或 CSS 框架。这样做的一个好消息是，在你遇到困难的时候，所有现成的库的源代码都会为你提供帮助。 把你学到的东西都记录下来最后，但丝毫不逊色的是，你应该把你学到的东西记录下来。这样做有很多原因，但也许最重要的原因是它强迫你更好的理解这件事。如果你无法讲清楚它的工作原理，在整个过程中它会推动你自己把并不真正理解的东西弄清楚。很多情况下你根本意识不到自己还不理解它们——直到自己动手写的时候。根据我的经验，写作、演讲、做 demo 是强迫自己完全深入理解一件事的最佳方式。就算你写的东西没有人看，整个过程也会让你受益匪浅。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css学习归纳总结（二）]]></title>
      <url>%2F2017%2F02%2F13%2FCSS_summary2%2F</url>
      <content type="text"><![CDATA[链接伪类1234a:link &#123;color: black&#125; /* 未访问的链接 */a:visited &#123;color: blue&#125; /* 已访问的链接 */a:hover &#123;color: red&#125; /* 当有鼠标悬停在链接上 */a:active &#123;color: purple&#125; /* 被选择的链接 */ 为了产生预期的效果，在CSS定义中，a:hover必须位于a:link和a:visited之后！a:active必须位于a:hover之后！！ :after和:before伪元素”伪元素“，顾名思义。它创建了一个虚假的元素，并插入到目标元素内容之前或之后。伪元素如果没有设置content属性，伪元素是无用的。 插入的元素默认情况下是内联元素，如果你要为其设置宽高等属性，你需要将他定义为块级元素123456#element:before&#123; content : &quot;&quot;; display : &apos;block&apos; height : 1000px; width : 1000px;&#125; 注入的内容将是有关联的目标元素的子元素，但它会被置于这个元素的任何内容的“前”或“后”。 web标准的构成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css学习归纳总结（一）]]></title>
      <url>%2F2017%2F02%2F12%2FCSS_summary1%2F</url>
      <content type="text"><![CDATA[css温习归纳系列 选择器的分组CSS选择器分为 123456789101.群组选择器 如：p,body,img,div&#123;&#125;2.兄弟选择器 如：p+p &#123; color:#f00; &#125;3.属性选择器 如：p[title] &#123; color&#125;4.包含（后代）选择器 如：body ul li&#123;&#125;5.子元素选择器 如：div &gt; p&#123;&#125;6.ID选择器 如： #myDiv&#123;&#125;7.类选择器 如： .class1&#123;&#125;8.伪元素选择器 如： E:first-line,E:before9.伪类选择器 如：E:first-child, E:visited, E:focus, E:enabled10.标签选择器 如：p &#123; font-size:1em &#125; 子代选择器和后代选择器的区别： 1后代选择器的写法就是把外层的标记写在前面，内层的标记写在后面，之间用空格分隔。子选择器只对直接后代有影响的选择器，而对“孙子后代”以及多层后代不产生作用。 注意：在IE6中，只支持后代选择器，不支持子选择器（然而现在还需要考虑这个么 -。-！） 盒子模型css框模型介绍： 给ul下的li设置宽度，那么他们将平均掉它们所占容器的宽度。div&gt;ul&gt;li&gt;a标签所占宽度和高度： 当你为body元素指定div时，每个div默认的宽为浏览器的100%，高度在每个浏览器的解析都不一样，比如在火狐下是131px，在chrome下则是142px，具体机制不明 css字体速记规则当用css定义字体样式的时候，你也许会这样做： 123456font-weight: bold;font-style: italic;font-variant: small-caps;font-size: 1em;line-height: 1.5em;font-family: verdana,sans-serif 没有必要这样做，因为你可以使用css速记属性： 1font: bold italic small-caps 1em/1.5em verdana,sans-serif 值得注意的是：css速记版本只会指定font-size和font-family属性时才会生效。如果你没有指定font-weight,font-style,或者font-variant，那么这些值将会自动默认为normal 避免多余选择器有时候你会有如下的写法： 12345ul li &#123; ... &#125;ol li &#123; ... &#125; table tr td &#123; ... &#125; 但实际上这是没必要的写法，因为&lt;li&gt;会且只会与&lt;ul&gt;或&lt;ol&gt;连用，就像&lt;td&gt;只能存在于&lt;tr&gt;和&lt;table&gt;中一样，这儿真没有把它们重复一次的必要。 !important所有被!important标记的样式，即使它后来被重写，浏览器也只会采用被标记的那条。 1234#content&#123; height:960px !important; height:900px;&#125; !important: IE7/IE8/IE9/FireFox可以识别上面附加!important的语句，看到附加!important的语句后，就不会再去执行第二句，尽管他们也“认识”第二句，但是附加“!important”的语句拥有绝对优先级，只要有它存在，第二句就不允许执行。 IE6会执行!important的语句后，再去执行第二句“height:900px”,用后面的样式覆盖了前面的样式，所以在IE6下，最终的height值是900px。（IE6拜拜，走好不送） @import and 在决定使用使用哪种方法去包含你的样式表之前，你应该明白这两种方法被用来干嘛？ 链接式：link就是把外部CSS与网页连接起来，将其加在&lt;head&gt;头部标签中，具体形式如下： 1&lt;link href=&quot;styles.css&quot; type=&quot;text/css&quot; /&gt; 导入样式：通过两个或以上的css文件共同部分，在[css]页面引入css文件，通过@import url（” “） 123@import url(&quot;global.css&quot;);@import url(global.css);@import &quot;global.css&quot;; 以上三种方式都有效， 区别：12341）link属于XHTML标签，而@import是CSS提供的; 2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; 3）@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题; 4）link方式的样式的权重 高于@import的权重. 行内元素、块元素和空元素行内元素特点123451、和其他元素都在一行上；2、元素的高度、宽度、行高及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 行内元素在设置水平方向的[padding-left、padding-right、margin-left、margin-right]都产生边距效果，但竖直方向的[padding-top、padding-bottom、margin-top、margin-bottom]都不会产生边距效果。 块级元素特点123451、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 块级元素是可以设置宽高的，但是它的实际宽高是本身宽高+padding。block元素要单独占一行。内联元素不单独占一行，给他设置宽高是没有用的。 块级元素和行内元素列表： 空元素知名的空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;鲜为人知的是：&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 长度单位emem为相对长度单位，相对于当前对象内文本的字体尺寸(font-size)。比如：Web页面中body的文字大小在用户浏览器下默认渲染是16px，所以，此时的1em = 16px; remem单位是相对于父节点的font-size，会有一些组合的问题，而rem是相对于根节点（或者是html节点），也就是说你可以在html节点定义一个单独的字体大小，然后所有其他元素使用rem相对于这个字体的百分比进行设置，这样就意味着，我们只需要在根元素确定一个参考值，在根元素中设置多大的字体，这完全可以根据您自己的需. small&lt;small&gt;标签呈现小号字体效果 &lt;strong&gt;,&lt;em&gt;和&lt;b&gt;,&lt;i&gt;标签 1234`&lt;strong&gt;` 标签和 `&lt;em&gt;` 标签一样，用于强调文本，但它强调的程度更强一些。`em` 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 `&lt;i&gt;...&lt;/i&gt;`;`&lt; b &gt; &lt; i &gt;` 是视觉要素，分别表示无意义的加粗，无意义的斜体。em 和 strong 是表达要素(phrase elements)。 b标签和i标签的区别12345b 元素现在描述为在普通文章中仅从文体上突出的不包含任何额外的重要性的一段文本。 例如：文档概要中的关键字，评论中的产品名。或者代表强调的排版方式。i 元素现在描述为在普通文章中突出不同意见或语气或其他的一段文本， 例如：一个分类名称，一个技术术语，一个外语中的谚语，一个想法等。或者代表斜体的排版方式。 CSS多类选择器一个class值中可能包含一个词列表，各个词之间用空格分隔。例如，如果希望将一个特定的元素同时标记为重要（important）和警告（warning），就可以写作：123&lt;p class=&quot;important warning&quot;&gt;This paragraph is a very important warning.&lt;/p&gt; 对于ID来说，就不能这样写了 所有浏览器下的CSS透明度元素透明度时常是个恼人的问题，下面这种方式可以实现所有浏览器下的透明度设置：12345.transparent &#123; zoom: 1; filter: alpha(opacity=50); opacity: 0.5;&#125; Zoom属性是IE浏览器的专有属性，Firefox等浏览器不支持。它可以设置或检索对象的缩放比例。除此之外，它还有其他一些小作用，比如触发IE的hasLayout属性，清除浮动、清除margin的重叠等。 CSS float属性定义和用法float属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。注释：假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 伟大的塌陷使用浮动(float)的一个比较疑惑的事情是他们怎么影响包含他们的父元素的。如果父元素只包含浮动元素，那么它的高度就会塌缩为零。如果父元素不包含任何的可见背景，这个问题会很难被注意到塌陷的直观对立面更不好，看看下面的情况： 清除浮动如果你很明确的知道接下来的元素会是什么，可以使用 clear:both; 来清除浮动。这个方法很不错，它不需要 hack，不添加额外的元素也使得它有良好的语义性。 使用css伪选择符(:after)来清除浮动：1234567.clearfix:after &#123; content: &quot;.&quot;; visibility: hidden; display: block; height: 0; clear: both; &#125; 渐进增强与优雅降级概念优雅降级和渐进增强印象中是随着css3流出来的一个概念。由于低级浏览器不支持css3，但css3的效果又太优秀不忍放弃，所以在高级浏览中使用 css3而低级浏览器只保证最基本的功能。咋一看两个概念差不多，都是在关注不同浏览器下的不同体验，关键的区别是他们所侧重的内容，以及这种不同造成的 工作流程的差异。 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 visibility:hidden和display:none1234display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。 text文本属性text-indenttext-intent属性规定文本块中首行文本的缩进。注释：允许使用负值。如果使用负值，那么首行会被缩进到左边。使用一个较大的负值进行缩进的话，文字将被隐藏，如-9999em letter-spacing与word-spacingletter-spacing属性与word-spacing的区别在于，前者是修改字母的间隔，后者是修改单词或单个文字的间隔 text-transformtext-transform属性处理文本的大小写。这个属性有4个值：1234noneuppercase：所有的单词都大写lowercase：所有的单词都小写capitalize：只对每个单词的首字母大写 text-decorationtext-decoration有5个值：12345noneunderline：下划线overline：上划线line-through：在文本中间画一个贯穿线blink：让文本闪烁 white-space12345pre-line 合并空白符序列，但保留换行符 normal nowrap 防止元素中的文本换行pre 空白符不会被忽略pre-wrap 保留空白符序列]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js入门]]></title>
      <url>%2F2017%2F01%2F15%2FVue.js_introduction%2F</url>
      <content type="text"><![CDATA[简单总结刚入门的Vue.js。 什么是Vue？上图： 个人理解Vue是MVVM模型的代表，主要用于在前端做DOM和数据的绑定控制，比常规直接操作DOM的方法拥有更高的效率，其他的类似的还有React和Angular。 介绍Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 Vue特点 简洁： HTML 模板 + JSON 数据，再创建一个 Vue 实例，就这么简单。 数据驱动： 自动追踪依赖的模板表达式和计算属性。 组件化： 用解耦、可复用的组件来构造界面。 轻量： ~24kb min+gzip，无依赖。 快速： 精确有效的异步批量 DOM 更新。 模块友好： 通过 NPM 或 Bower 安装，无缝融入你的工作流。 如果你喜欢下面这些，那你一定会喜欢 Vue.js： 可扩展的数据绑定机制 原生对象即模型 简洁明了的 API 组件化 UI 构建 多个轻量库搭配使用 例子双向绑定12345678&#123;&#123; message &#125;&#125;new Vue(&#123; el:&apos;#app&apos;, data: &#123; message:&apos;Hello World!&apos; &#125;&#125;); 列表循环12345678910111213141516&lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125;&lt;/li&gt;or &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; $index &#125;&#125; - &#123;&#123; item.message &#125;&#125;new Vue(&#123; el: &apos;#app&apos;, data: &#123; todos: [ &#123; text: &apos;Learn JavaScript&apos; &#125;, &#123; text: &apos;Learn Vue.js&apos; &#125;, &#123; text: &apos;Build Something Awesome&apos; &#125; ] &#125;&#125;) 条件判断12345678910&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt; 随机数大于 0.5&lt;/div&gt;&lt;div v-else&gt; 随机数不大于 0.5&lt;/div&gt;new Vue(&#123; el: &apos;#app&apos;&#125;) 过滤器类似Linux的管道传输。 1234567891011&#123;&#123;message | reverse | uppercase&#125;&#125;Vue.filter(&apos;reverse&apos;, function (value) &#123; return value.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;)new Vue(&#123; el: &apos;#app&apos;, data: &#123; message:&apos;www.iamlj.com&apos; &#125;&#125;) 综合示例包括model，enter，click，for特性。 123456789101112131415161718192021222324252627282930313233&lt;input v-model=&quot;newTodo&quot; v-on:keyup.enter=&quot;addTodo&quot;&gt;&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &lt;span&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt; &lt;button v-on:click=&quot;removeTodo($index)&quot;&gt;X&lt;/button&gt; &lt;/li&gt;&lt;/ul&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; newTodo: &apos;&apos;, todos: [&#123; text: &apos;Add some todos&apos; &#125;,&#123; text: &apos;Add some todos1&apos; &#125;] &#125;, methods: &#123; addTodo: function() &#123; var text = this.newTodo.trim() if (text) &#123; this.todos.push(&#123; text: text &#125;) this.newTodo = &apos;&apos; &#125; &#125;, removeTodo: function(index) &#123; this.todos.splice(index, 1) &#125; &#125;&#125;) 学习参考 http://cn.vuejs.org/guide/ http://www.runoob.com/w3cnote/vue-js-quickstart.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript性能优化]]></title>
      <url>%2F2017%2F01%2F13%2FJS_optimization%2F</url>
      <content type="text"><![CDATA[取代采用了事件委托来绑定父节点ul的事件侦听，提高性能。 原题1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;性能优化&lt;/title&gt; &lt;style&gt; #action-list li &#123; padding: 10px 15px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;点击以下做出相应的动作&lt;h2&gt; &lt;ul id="action-list"&gt; &lt;li id="action-a"&gt;页面输入hello world&lt;/li&gt; &lt;li id="action-b"&gt;页面弹出hello world&lt;/li&gt; &lt;li id="action-c"&gt;页面确认hello world&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var actionA = document.getElementById("action-a"); actionA.addEventListener("click", function()&#123; prompt("输入Hello World："); &#125;); var actionB = document.getElementById("action-b"); actionB.addEventListener("click", function()&#123; alert("Hello World"); &#125;); var actionC = document.getElementById("action-c"); actionC.addEventListener("click", function()&#123; confirm("Hello World"); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解题这里采用事件委托，将在li对象上面要处理的事件委托给父元素或者祖先元素，即为父元素绑定事件侦听。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;性能优化&lt;/title&gt; &lt;style&gt; #action-list li &#123; padding: 10px 15px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;点击以下做出相应的动作&lt;/h2&gt; &lt;ul id="action-list"&gt; &lt;li id="action-1"&gt;页面输入hello world&lt;/li&gt; &lt;li id="action-2"&gt;页面弹出hello world&lt;/li&gt; &lt;li id="action-3"&gt;页面确认hello world&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; (function () &#123; var a = document.getElementById('action-list'); a.addEventListener('click', function (e) &#123; var b = e.target; var idNum = b.id.substring(7); doEvent(idNum); &#125;, false); &#125;)(); function doEvent(idNum) &#123; switch (true) &#123; case idNum == 1: prompt("输入Hello World："); break; case idNum == 2: alert("Hello World"); break; default: confirm("Hello World"); break; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记第一次实习感悟]]></title>
      <url>%2F2017%2F01%2F12%2FInternship_comprehension%2F</url>
      <content type="text"><![CDATA[八月的最后一天，关于实习技术上的总结。PHP的起步就来这么硬的菜：关于搭框架的那些事–我们造着轮子滑着水 天才程序员去创造工具，大众程序员去使用工具，大部分人都处于“使用”这个层次，本人就是其中之一（这不是废话吗）。创造是一件很难的事情，但模仿却简单的多。所谓的框架，和工具不同，工具拿过来直接可用，而框架只是个半成品。换句话说就是大牛写的框架代码，加上我们写的代码，才能形成一个系统，才能运行起来。想一想，单独的Symfony不能运行。框架是个半成品（但不是残次品），我们要想用起来，非得自己填上代码不可。那些大牛们（比如说wellming）写框架的时候得考虑用户怎么配合才行，所以得定义好边界，哪些是框架的任务，哪些是程序员应该做的扩展。我们想修改框架的东西，门儿都没有，对修改完全封闭。但是框架又提供了一些地方让程序员扩展，这就是著名的面向对象设计的原则之一：Open-Close原则（即开闭原则）。想达成这个目标，最容易的方式就是“继承”，常用的就是抽象类抽象类有这样的好处：1.没法实例化去执行（符合框架半成品的特点）。2.可以被继承，抽象方法需要使用者去实现。3.可以在抽象类中写代码，写框架相关的代码，还可以调用抽象方法。模板方法假设写一个MVC的框架，希望定义一个抽象类AbstractAction，把一些框架应该做的事封装起来，这些操作和步骤是子类不能修改的–Close虽然是封闭的，但是框架的使用者却可以去继承这类，实现方法，放置自己的业务代码。–Open当然除了实现自己的代码之外，对超类一无所知。–又是Close模板方法看起来很美，但是有个巨大的问题，就是对客户侵入性太强。表现在两个方面：1.子类（业务类）很不自由，被迫继承一个它不想继承的类。2.难于做单元测试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo基于Github Pages搭建个人博客（二）]]></title>
      <url>%2F2017%2F01%2F10%2FHexo_course2%2F</url>
      <content type="text"><![CDATA[上一篇介绍了 GitHub Pages 服务开启，这篇文章将介绍 Hexo 的安装和使用以及将博客部署到 GitHub Pages 的操作。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 一、Node.js 安装Hexo 是基于 Node.js 安装，所以安装Hexo之前首先要安装 Node.js。下载地址：https://nodejs.org/en/download/ 根据自己的操作系统，下载对应版本即可。安装过程比较简单，一直下一步即可安装完成。 二、Hexo 安装打开 Git Bash输入以下命令开始安装Hexo 1npm install hexo-cli -g 出现以下界面表示安装完成 三、Hexo 建站安装 Hexo 完成后，在本地磁盘创建一个目录用于存放 Hexo 配置文件和博客源代码，我的 Hexo 存放在 C:/hexo 目录下。 分别执行下列命令，Hexo 将会在 C:/hexo新建所需要的文件 123456# 进入 C:/hexo 目录cd /c/hexo/# 初始化所需要的文件到 Hexo 文件夹hexo init hexo# 安装npm install 分别执行以下命令在本地进行预览1234# 编译生成博文hexo generate# 启动Hexo服务器hexo server 出现以下画面表示服务启动成功 打开浏览器输入 http://localhost:4000/ 便可以看到最原始的博客了 四、Hexo 部署到 GitHub Pages更新 Hexo 安装文件夹中 _config.yml 文件，如图 更新_config.yml文件中的 deploy 节点，如图所示，可添加多个地址（如一个 GitHub、Coding、oschina） 分别执行以下命令即可完成部署 1234npm install hexo-deployer-git --save # 安装 hexo-deployer-githexo clean # 可简写为 hexo clhexo generate # 可简写为 hexo ghexo deploy # 可简写为 hexo d 访问 https://yourname.github.io 即可看到博客模板的内容，对于Hexo 的一些详细设置可以参考Hexo官方文档 。本站使用的Hexo主题是 NexT，详细设置可参考 Next主题官方网站。 文章是 MarkDown 格式文件（关于 Markdown 语法可参考Markdown 语法说明(简体中文版)），编辑文章后保存，可以先启动本地 Hexo Server 查看效果，然后执行部署命令就完成了博客文章的发布 至此，使用 Hexo 基于 GitHub Pages 搭建个人博客就介绍完了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo基于Github Pages搭建个人博客（一）]]></title>
      <url>%2F2017%2F01%2F09%2FHexo_course1%2F</url>
      <content type="text"><![CDATA[Github Pages是github提供的免费开源的静态站点托管服务，利用这个服务可以搭建轻量级的博客系统，本文介绍了如何使用Hexo结合 GitHub Pages 服务搭建个人博客。 一、安装配置Git1.1安装Git使用 GitHub 首先要安装 Git，可根据操作系统下载不同版本的 Git，Windows 下载地址：https://git-scm.com/download/win 安装过程比较简单，选择默认选项配置即可下一步，不再叙述。 1.2配置Git设置本地机器默认 commit 的昵称与 Email，姓名与 Email 只用于日志标识，实际推送到远程仓库时，要用有操作权限的账号登录。 12git config --global user.name &quot;ehlxr&quot; git config --global user.email &quot;ehlxr@qq.com&quot; 二、生成SSH KeysSSH Keys 是 GitHub 推荐的公钥、秘钥形式验证用户合法性的机制，添加 SSH Keys 可以省去每次都要输入密码的步骤，下面将演示如何在本地计算机生成 SSH Keys的公钥、秘钥。 2.1首先打开安装的 Git Bash 2.2 运行 ssh-keygen 命令输入以下命令：（替换 &quot;your_email@example.com&quot; 为注册时候的邮箱） 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 2.3 保存秘钥文件当出现以下提示时，直接敲回车键选择默认地址即可（保存私钥文件位置，默认保存在当前用户文件夹下的 .ssh 文件夹中，文件名称为 id_rsa ） 1Enter file in which to save the key (/c/Users/lt/.ssh/id_rsa): 如果已经存在会提示，输入：y 敲回车替换即可 12/c/Users/lt/.ssh/id_rsa already exists.Overwrite (y/n)? 出现以下提示设置密码提示，不用设置密码，敲回车键即可 1Enter passphrase (empty for no passphrase): 再次确认密码提示，不用设密码敲回车即可 1Enter same passphrase again: 出现以下提示，表明已经成功生成了 SSH Keys 12345678910111213141516Your identification has been saved in /c/Users/lt/.ssh/id_rsa.Your public key has been saved in /c/Users/lt/.ssh/id_rsa.pub.The key fingerprint is:SHA256:dBtq6OOJs1JQat630kGqh420Y0JSb7smaR6c9jjo7h0 your_email@example.comThe key&apos;s randomart image is:+---[RSA 4096]----+| || . || o . o || = .o o o || + + o. S . ||.oo.*.o. ||oo=E +oo ||o.#+Oooo ||+OoO==o |+----[SHA256]-----+ Github 官网 SSH Keys 生成教程 三、开启 GitHub Pages 服务GitHub 账户注册比较简单，注册免费使用的账户就可以了，这里就不细说了，需要注意的是尽量不要使用 126/163 邮箱注册，我在测试的时候收不到验证码，等收到验证码的时候已经第二天了，早就过期了，我使用 Gmail 和 QQ 邮箱都能很快收到验证码。 3.1 添加生成的 SSH Keys 到 GitHub打开生成的 SSH Keys 公钥 登录注册的 GitHub 账户，按照以下图示 1、2、3、4、5、6、7 步骤操作，复制公钥内容粘贴到下图 步骤 5 的Key 输入框中，在 步骤6输入一个标题，点击 步骤 7 的 Add SSH key 按钮，这时候会提示你输入 GitHub账号密码，输入密码确认即可添加成功。 3.2 创建 GitHub 仓库 填写完仓库名称，其他选项默认，点击Create repository即可完成创建。 3.3 测试 GitHub Pages服务接下来在仓库根目录下创建一个 index.html 文件测试 GitHub Pages 服务是否开启成功。打开刚才创建的仓库，因为我们之前已经添加了 SSH Keys，所以选择复制如下图所示的SSH仓库连接 在电脑磁盘创建一个文件夹（我创建在：D:/lxr）在 Git Bash 分别输入以下两条命令： 12cd /d/lxr/ # 进入创建的文件夹git init # 初始化本地仓库 在本地文件夹中创建 index.html 文件，随便输入一些内容即可，命令如下： 1echo &quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot; &gt;&gt; index.html # 创建 index.html 文件 然后分别执行以下命令： 1234git add index.html # 添加文件git commit -m &quot;create index.html&quot; # 提交文件git remote add origin git@github.com:ehlxr/ehlxr.github.io.git # 添加 GitHub 仓库地址，注意地址填写自己注册的 GitHub 仓库地址git push -u origin master # push 到 GitHub 浏览器访问：yourname.github.io 如果出现 index.html 输入的内容，即GitHub Pages服务开启成功]]></content>
    </entry>

    
  
  
</search>
